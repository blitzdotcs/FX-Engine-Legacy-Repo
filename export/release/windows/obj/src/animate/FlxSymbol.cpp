// Generated by Haxe 4.3.1
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_animate_FlxSymbol
#include <animate/FlxSymbol.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimation
#include <flixel/animation/FlxAnimation.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxBaseAnimation
#include <flixel/animation/FlxBaseAnimation.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFrame
#include <flixel/graphics/frames/FlxFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxGraphicsShader
#include <flixel/graphics/tile/FlxGraphicsShader.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMatrix
#include <flixel/math/FlxMatrix.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxPoint
#include <flixel/util/FlxPool_flixel_math_FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsShader
#include <openfl/display/GraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_8cae46e41d5edf1a_11_new,"animate.FlxSymbol","new",0x93f284af,"animate.FlxSymbol.new","animate/FlxSymbol.hx",11,0xd95b6322)
HX_LOCAL_STACK_FRAME(_hx_pos_8cae46e41d5edf1a_34_draw,"animate.FlxSymbol","draw",0xd9af3cd5,"animate.FlxSymbol.draw","animate/FlxSymbol.hx",34,0xd95b6322)
HX_LOCAL_STACK_FRAME(_hx_pos_8cae46e41d5edf1a_49_renderFrame,"animate.FlxSymbol","renderFrame",0x0a26c046,"animate.FlxSymbol.renderFrame","animate/FlxSymbol.hx",49,0xd95b6322)
HX_LOCAL_STACK_FRAME(_hx_pos_8cae46e41d5edf1a_133_setDaMap,"animate.FlxSymbol","setDaMap",0x45652d6e,"animate.FlxSymbol.setDaMap","animate/FlxSymbol.hx",133,0xd95b6322)
HX_LOCAL_STACK_FRAME(_hx_pos_8cae46e41d5edf1a_141_changeFrame,"animate.FlxSymbol","changeFrame",0x643b3bec,"animate.FlxSymbol.changeFrame","animate/FlxSymbol.hx",141,0xd95b6322)
HX_LOCAL_STACK_FRAME(_hx_pos_8cae46e41d5edf1a_145_parseSymbolDictionary,"animate.FlxSymbol","parseSymbolDictionary",0x7c461b70,"animate.FlxSymbol.parseSymbolDictionary","animate/FlxSymbol.hx",145,0xd95b6322)
HX_LOCAL_STACK_FRAME(_hx_pos_8cae46e41d5edf1a_171_drawComplex,"animate.FlxSymbol","drawComplex",0x04abc5db,"animate.FlxSymbol.drawComplex","animate/FlxSymbol.hx",171,0xd95b6322)
HX_LOCAL_STACK_FRAME(_hx_pos_8cae46e41d5edf1a_215_updateSkewMatrix,"animate.FlxSymbol","updateSkewMatrix",0x9fc1f6a5,"animate.FlxSymbol.updateSkewMatrix","animate/FlxSymbol.hx",215,0xd95b6322)
HX_LOCAL_STACK_FRAME(_hx_pos_8cae46e41d5edf1a_37_boot,"animate.FlxSymbol","boot",0xd85a9503,"animate.FlxSymbol.boot","animate/FlxSymbol.hx",37,0xd95b6322)
namespace animate{

void FlxSymbol_obj::__construct(Float x,Float y, ::Dynamic coolParsed){
            	HX_GC_STACKFRAME(&_hx_pos_8cae46e41d5edf1a_11_new)
HXLINE( 212)		 ::flixel::math::FlxPoint point = ::flixel::math::FlxPoint_obj::_pool->get()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN( 212)		point->_inPool = false;
HXDLIN( 212)		this->skew = point;
HXLINE( 210)		this->matrixExposed = false;
HXLINE( 202)		this->_skewMatrix =  ::openfl::geom::Matrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE(  46)		this->transformMatrix =  ::openfl::geom::Matrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE(  44)		this->nestDepth = 0;
HXLINE(  43)		this->daFrame = 0;
HXLINE(  41)		this->drawQueue = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  39)		this->symbolMap =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE(  30)		this->symbolAtlasShit =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE(  16)		this->hasFrameByPass = false;
HXLINE(  14)		this->oldMatrix = ::Array_obj< Float >::__new(0);
HXLINE(  20)		super::__construct(x,y,null());
HXLINE(  22)		this->coolParse = coolParsed;
HXLINE(  24)		bool hasSymbolDictionary = ::Reflect_obj::hasField(this->coolParse,HX_("SD",91,48,00,00));
HXLINE(  26)		if (hasSymbolDictionary) {
HXLINE(  27)			this->symbolAtlasShit = this->parseSymbolDictionary(this->coolParse);
            		}
            	}

Dynamic FlxSymbol_obj::__CreateEmpty() { return new FlxSymbol_obj; }

void *FlxSymbol_obj::_hx_vtable = 0;

Dynamic FlxSymbol_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FlxSymbol_obj > _hx_result = new FlxSymbol_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool FlxSymbol_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x39c55849) {
		if (inClassId<=(int)0x2c01639b) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2c01639b;
		} else {
			return inClassId==(int)0x39c55849;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void FlxSymbol_obj::draw(){
            	HX_STACKFRAME(&_hx_pos_8cae46e41d5edf1a_34_draw)
HXDLIN(  34)		this->super::draw();
            	}


void FlxSymbol_obj::renderFrame( ::Dynamic TL, ::Dynamic coolParsed, ::Dynamic __o_isMainLoop){
            		 ::Dynamic isMainLoop = __o_isMainLoop;
            		if (::hx::IsNull(__o_isMainLoop)) isMainLoop = false;
            	HX_GC_STACKFRAME(&_hx_pos_8cae46e41d5edf1a_49_renderFrame)
HXLINE(  50)		this->drawQueue = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  52)		{
HXLINE(  52)			int _g = 0;
HXDLIN(  52)			::Array< ::Dynamic> _g1 = ( (::Array< ::Dynamic>)(TL->__Field(HX_("L",4c,00,00,00),::hx::paccDynamic)) );
HXDLIN(  52)			while((_g < _g1->length)){
HXLINE(  52)				 ::Dynamic layer = _g1->__get(_g);
HXDLIN(  52)				_g = (_g + 1);
HXLINE(  57)				{
HXLINE(  57)					int _g2 = 0;
HXDLIN(  57)					::Array< ::Dynamic> _g3 = ( (::Array< ::Dynamic>)(layer->__Field(HX_("FR",4c,3d,00,00),::hx::paccDynamic)) );
HXDLIN(  57)					while((_g2 < _g3->length)){
HXLINE(  57)						 ::Dynamic frame = _g3->__get(_g2);
HXDLIN(  57)						_g2 = (_g2 + 1);
HXLINE(  59)						bool _hx_tmp;
HXDLIN(  59)						if (::hx::IsGreaterEq( this->daFrame,frame->__Field(HX_("I",49,00,00,00),::hx::paccDynamic) )) {
HXLINE(  59)							_hx_tmp = ::hx::IsLess( this->daFrame,(frame->__Field(HX_("I",49,00,00,00),::hx::paccDynamic) + frame->__Field(HX_("DU",91,3b,00,00),::hx::paccDynamic)) );
            						}
            						else {
HXLINE(  59)							_hx_tmp = false;
            						}
HXDLIN(  59)						if (_hx_tmp) {
HXLINE(  61)							int _g4 = 0;
HXDLIN(  61)							::Array< ::Dynamic> _g5 = ( (::Array< ::Dynamic>)(frame->__Field(HX_("E",45,00,00,00),::hx::paccDynamic)) );
HXDLIN(  61)							while((_g4 < _g5->length)){
HXLINE(  61)								 ::Dynamic element = _g5->__get(_g4);
HXDLIN(  61)								_g4 = (_g4 + 1);
HXLINE(  63)								if (::Reflect_obj::hasField(element,HX_("ASI",17,9b,31,00))) {
HXLINE(  65)									::Array< Float > m3d = ( (::Array< Float >)( ::Dynamic(element->__Field(HX_("ASI",17,9b,31,00),::hx::paccDynamic))->__Field(HX_("M3D",3e,9a,3a,00),::hx::paccDynamic)) );
HXLINE(  66)									 ::openfl::geom::Matrix dumbassMatrix =  ::openfl::geom::Matrix_obj::__alloc( HX_CTX ,m3d->__get(0),m3d->__get(1),m3d->__get(4),m3d->__get(5),m3d->__get(12),m3d->__get(13));
HXLINE(  68)									 ::animate::FlxSymbol spr =  ::animate::FlxSymbol_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),coolParsed);
HXLINE(  69)									this->matrixExposed = true;
HXLINE(  70)									spr->set_frames(this->frames);
HXLINE(  71)									spr->set_frame(( ( ::flixel::graphics::frames::FlxFrame)(spr->frames->framesHash->get( ::Dynamic( ::Dynamic(element->__Field(HX_("ASI",17,9b,31,00),::hx::paccDynamic))->__Field(HX_("N",4e,00,00,00),::hx::paccDynamic)))) ));
HXLINE(  75)									dumbassMatrix->concat(this->_matrix);
HXLINE(  76)									spr->matrixExposed = true;
HXLINE(  77)									spr->transformMatrix->concat(dumbassMatrix);
HXLINE(  80)									spr->origin->set(null(),null());
HXLINE(  81)									 ::flixel::math::FlxPoint fh = spr->origin;
HXDLIN(  81)									fh->set_x((fh->x + this->origin->x));
HXLINE(  82)									 ::flixel::math::FlxPoint fh1 = spr->origin;
HXDLIN(  82)									fh1->set_y((fh1->y + this->origin->y));
HXLINE(  84)									spr->set_antialiasing(true);
HXLINE(  85)									spr->draw();
            								}
            								else {
HXLINE(  89)									 ::Dynamic nestedSymbol = this->symbolMap->get( ::Dynamic( ::Dynamic(element->__Field(HX_("SI",96,48,00,00),::hx::paccDynamic))->__Field(HX_("SN",9b,48,00,00),::hx::paccDynamic)));
HXLINE(  90)									 ::animate::FlxSymbol nestedShit =  ::animate::FlxSymbol_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),this->coolParse);
HXLINE(  91)									nestedShit->set_frames(this->frames);
HXLINE(  93)									 ::flixel::math::FlxMatrix swagMatrix =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX , ::Dynamic( ::Dynamic(element->__Field(HX_("SI",96,48,00,00),::hx::paccDynamic))->__Field(HX_("M3D",3e,9a,3a,00),::hx::paccDynamic))->__GetItem(0), ::Dynamic( ::Dynamic(element->__Field(HX_("SI",96,48,00,00),::hx::paccDynamic))->__Field(HX_("M3D",3e,9a,3a,00),::hx::paccDynamic))->__GetItem(1), ::Dynamic( ::Dynamic(element->__Field(HX_("SI",96,48,00,00),::hx::paccDynamic))->__Field(HX_("M3D",3e,9a,3a,00),::hx::paccDynamic))->__GetItem(4), ::Dynamic( ::Dynamic(element->__Field(HX_("SI",96,48,00,00),::hx::paccDynamic))->__Field(HX_("M3D",3e,9a,3a,00),::hx::paccDynamic))->__GetItem(5), ::Dynamic( ::Dynamic(element->__Field(HX_("SI",96,48,00,00),::hx::paccDynamic))->__Field(HX_("M3D",3e,9a,3a,00),::hx::paccDynamic))->__GetItem(12), ::Dynamic( ::Dynamic(element->__Field(HX_("SI",96,48,00,00),::hx::paccDynamic))->__Field(HX_("M3D",3e,9a,3a,00),::hx::paccDynamic))->__GetItem(13));
HXLINE(  96)									swagMatrix->concat(this->_matrix);
HXLINE(  98)									nestedShit->_matrix->concat(swagMatrix);
HXLINE(  99)									nestedShit->origin->set( ::Dynamic( ::Dynamic(element->__Field(HX_("SI",96,48,00,00),::hx::paccDynamic))->__Field(HX_("TRP",12,05,40,00),::hx::paccDynamic))->__Field(HX_("x",78,00,00,00),::hx::paccDynamic), ::Dynamic( ::Dynamic(element->__Field(HX_("SI",96,48,00,00),::hx::paccDynamic))->__Field(HX_("TRP",12,05,40,00),::hx::paccDynamic))->__Field(HX_("y",79,00,00,00),::hx::paccDynamic));
HXLINE( 103)									bool _hx_tmp1 = this->symbolAtlasShit->exists(( (::String)(nestedSymbol->__Field(HX_("SN",9b,48,00,00),::hx::paccDynamic)) ));
HXLINE( 114)									nestedShit->hasFrameByPass = true;
HXLINE( 115)									nestedShit->nestDepth = (this->nestDepth + 1);
HXLINE( 116)									nestedShit->renderFrame(nestedSymbol->__Field(HX_("TL",78,49,00,00),::hx::paccDynamic),coolParsed,null());
            								}
            							}
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxSymbol_obj,renderFrame,(void))

void FlxSymbol_obj::setDaMap( ::animate::FlxSymbol spr){
            	HX_STACKFRAME(&_hx_pos_8cae46e41d5edf1a_133_setDaMap)
HXDLIN( 133)		if (!(::animate::FlxSymbol_obj::nestedShit->exists(this->nestDepth))) {
HXLINE( 134)			::animate::FlxSymbol_obj::nestedShit->set(this->nestDepth,::Array_obj< ::Dynamic>::__new(1)->init(0,spr));
            		}
            		else {
HXLINE( 136)			( (::Array< ::Dynamic>)(::animate::FlxSymbol_obj::nestedShit->get(this->nestDepth)) )->push(spr);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSymbol_obj,setDaMap,(void))

void FlxSymbol_obj::changeFrame(::hx::Null< int >  __o_frameChange){
            		int frameChange = __o_frameChange.Default(0);
            	HX_STACKFRAME(&_hx_pos_8cae46e41d5edf1a_141_changeFrame)
HXDLIN( 141)		 ::animate::FlxSymbol _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 141)		_hx_tmp->daFrame = (_hx_tmp->daFrame + frameChange);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSymbol_obj,changeFrame,(void))

 ::haxe::ds::StringMap FlxSymbol_obj::parseSymbolDictionary( ::Dynamic coolParsed){
            	HX_GC_STACKFRAME(&_hx_pos_8cae46e41d5edf1a_145_parseSymbolDictionary)
HXLINE( 146)		 ::haxe::ds::StringMap awesomeMap =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE( 147)		{
HXLINE( 147)			int _g = 0;
HXDLIN( 147)			::Array< ::Dynamic> _g1 = ( (::Array< ::Dynamic>)( ::Dynamic(coolParsed->__Field(HX_("SD",91,48,00,00),::hx::paccDynamic))->__Field(HX_("S",53,00,00,00),::hx::paccDynamic)) );
HXDLIN( 147)			while((_g < _g1->length)){
HXLINE( 147)				 ::Dynamic symbol = _g1->__get(_g);
HXDLIN( 147)				_g = (_g + 1);
HXLINE( 149)				this->symbolMap->set(( (::String)(symbol->__Field(HX_("SN",9b,48,00,00),::hx::paccDynamic)) ),symbol);
HXLINE( 151)				::String symbolName = ( (::String)(symbol->__Field(HX_("SN",9b,48,00,00),::hx::paccDynamic)) );
HXLINE( 152)				{
HXLINE( 152)					int _g2 = 0;
HXDLIN( 152)					::Array< ::Dynamic> _g3 = ( (::Array< ::Dynamic>)( ::Dynamic(symbol->__Field(HX_("TL",78,49,00,00),::hx::paccDynamic))->__Field(HX_("L",4c,00,00,00),::hx::paccDynamic)) );
HXDLIN( 152)					while((_g2 < _g3->length)){
HXLINE( 152)						 ::Dynamic layer = _g3->__get(_g2);
HXDLIN( 152)						_g2 = (_g2 + 1);
HXLINE( 154)						{
HXLINE( 154)							int _g4 = 0;
HXDLIN( 154)							::Array< ::Dynamic> _g5 = ( (::Array< ::Dynamic>)(layer->__Field(HX_("FR",4c,3d,00,00),::hx::paccDynamic)) );
HXDLIN( 154)							while((_g4 < _g5->length)){
HXLINE( 154)								 ::Dynamic frame = _g5->__get(_g4);
HXDLIN( 154)								_g4 = (_g4 + 1);
HXLINE( 156)								{
HXLINE( 156)									int _g6 = 0;
HXDLIN( 156)									::Array< ::Dynamic> _g7 = ( (::Array< ::Dynamic>)(frame->__Field(HX_("E",45,00,00,00),::hx::paccDynamic)) );
HXDLIN( 156)									while((_g6 < _g7->length)){
HXLINE( 156)										 ::Dynamic element = _g7->__get(_g6);
HXDLIN( 156)										_g6 = (_g6 + 1);
HXLINE( 158)										if (::Reflect_obj::hasField(element,HX_("ASI",17,9b,31,00))) {
HXLINE( 160)											awesomeMap->set(symbolName, ::Dynamic( ::Dynamic(element->__Field(HX_("ASI",17,9b,31,00),::hx::paccDynamic))->__Field(HX_("N",4e,00,00,00),::hx::paccDynamic)));
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 167)		return awesomeMap;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSymbol_obj,parseSymbolDictionary,return )

void FlxSymbol_obj::drawComplex( ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_8cae46e41d5edf1a_171_drawComplex)
HXLINE( 172)		bool doFlipX = (this->flipX != this->_frame->flipX);
HXDLIN( 172)		bool _hx_tmp;
HXDLIN( 172)		if (::hx::IsNotNull( this->animation->_curAnim )) {
HXLINE( 172)			_hx_tmp = (doFlipX != this->animation->_curAnim->flipX);
            		}
            		else {
HXLINE( 172)			_hx_tmp = doFlipX;
            		}
HXDLIN( 172)		bool doFlipY = (this->flipY != this->_frame->flipY);
HXDLIN( 172)		bool _hx_tmp1;
HXDLIN( 172)		if (::hx::IsNotNull( this->animation->_curAnim )) {
HXLINE( 172)			_hx_tmp1 = (doFlipY != this->animation->_curAnim->flipY);
            		}
            		else {
HXLINE( 172)			_hx_tmp1 = doFlipY;
            		}
HXDLIN( 172)		this->_frame->prepareMatrix(this->_matrix,0,_hx_tmp,_hx_tmp1);
HXLINE( 173)		this->_matrix->translate(-(this->origin->x),-(this->origin->y));
HXLINE( 174)		this->_matrix->scale(this->scale->x,this->scale->y);
HXLINE( 176)		if (this->matrixExposed) {
HXLINE( 178)			this->_matrix->concat(this->transformMatrix);
            		}
            		else {
HXLINE( 182)			if ((this->bakedRotationAngle <= 0)) {
HXLINE( 184)				if (this->_angleChanged) {
HXLINE( 184)					Float radians = (this->angle * (::Math_obj::PI / ( (Float)(180) )));
HXDLIN( 184)					this->_sinAngle = ::Math_obj::sin(radians);
HXDLIN( 184)					this->_cosAngle = ::Math_obj::cos(radians);
HXDLIN( 184)					this->_angleChanged = false;
            				}
HXLINE( 186)				if ((this->angle != 0)) {
HXLINE( 187)					 ::flixel::math::FlxMatrix _this = this->_matrix;
HXDLIN( 187)					Float cos = this->_cosAngle;
HXDLIN( 187)					Float sin = this->_sinAngle;
HXDLIN( 187)					Float a1 = ((_this->a * cos) - (_this->b * sin));
HXDLIN( 187)					_this->b = ((_this->a * sin) + (_this->b * cos));
HXDLIN( 187)					_this->a = a1;
HXDLIN( 187)					Float c1 = ((_this->c * cos) - (_this->d * sin));
HXDLIN( 187)					_this->d = ((_this->c * sin) + (_this->d * cos));
HXDLIN( 187)					_this->c = c1;
HXDLIN( 187)					Float tx1 = ((_this->tx * cos) - (_this->ty * sin));
HXDLIN( 187)					_this->ty = ((_this->tx * sin) + (_this->ty * cos));
HXDLIN( 187)					_this->tx = tx1;
            				}
            			}
HXLINE( 191)			this->_matrix->concat(this->_skewMatrix);
            		}
HXLINE( 194)		this->_point->addPoint(this->origin);
HXLINE( 195)		if (this->isPixelPerfectRender(camera)) {
HXLINE( 196)			 ::flixel::math::FlxPoint _this1 = this->_point;
HXDLIN( 196)			_this1->set_x(( (Float)(::Math_obj::floor(_this1->x)) ));
HXDLIN( 196)			_this1->set_y(( (Float)(::Math_obj::floor(_this1->y)) ));
            		}
HXLINE( 198)		this->_matrix->translate(this->_point->x,this->_point->y);
HXLINE( 199)		camera->drawPixels(this->_frame,this->framePixels,this->_matrix,this->colorTransform,this->blend,this->antialiasing,null());
            	}


void FlxSymbol_obj::updateSkewMatrix(){
            	HX_STACKFRAME(&_hx_pos_8cae46e41d5edf1a_215_updateSkewMatrix)
HXLINE( 216)		this->_skewMatrix->identity();
HXLINE( 218)		bool _hx_tmp;
HXDLIN( 218)		if ((this->skew->x == 0)) {
HXLINE( 218)			_hx_tmp = (this->skew->y != 0);
            		}
            		else {
HXLINE( 218)			_hx_tmp = true;
            		}
HXDLIN( 218)		if (_hx_tmp) {
HXLINE( 220)			this->_skewMatrix->b = ::Math_obj::tan((this->skew->y * (::Math_obj::PI / ( (Float)(180) ))));
HXLINE( 221)			this->_skewMatrix->c = ::Math_obj::tan((this->skew->x * (::Math_obj::PI / ( (Float)(180) ))));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSymbol_obj,updateSkewMatrix,(void))

 ::haxe::ds::IntMap FlxSymbol_obj::nestedShit;


::hx::ObjectPtr< FlxSymbol_obj > FlxSymbol_obj::__new(Float x,Float y, ::Dynamic coolParsed) {
	::hx::ObjectPtr< FlxSymbol_obj > __this = new FlxSymbol_obj();
	__this->__construct(x,y,coolParsed);
	return __this;
}

::hx::ObjectPtr< FlxSymbol_obj > FlxSymbol_obj::__alloc(::hx::Ctx *_hx_ctx,Float x,Float y, ::Dynamic coolParsed) {
	FlxSymbol_obj *__this = (FlxSymbol_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FlxSymbol_obj), true, "animate.FlxSymbol"));
	*(void **)__this = FlxSymbol_obj::_hx_vtable;
	__this->__construct(x,y,coolParsed);
	return __this;
}

FlxSymbol_obj::FlxSymbol_obj()
{
}

void FlxSymbol_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxSymbol);
	HX_MARK_MEMBER_NAME(coolParse,"coolParse");
	HX_MARK_MEMBER_NAME(oldMatrix,"oldMatrix");
	HX_MARK_MEMBER_NAME(hasFrameByPass,"hasFrameByPass");
	HX_MARK_MEMBER_NAME(symbolAtlasShit,"symbolAtlasShit");
	HX_MARK_MEMBER_NAME(symbolMap,"symbolMap");
	HX_MARK_MEMBER_NAME(drawQueue,"drawQueue");
	HX_MARK_MEMBER_NAME(daFrame,"daFrame");
	HX_MARK_MEMBER_NAME(nestDepth,"nestDepth");
	HX_MARK_MEMBER_NAME(transformMatrix,"transformMatrix");
	HX_MARK_MEMBER_NAME(_skewMatrix,"_skewMatrix");
	HX_MARK_MEMBER_NAME(matrixExposed,"matrixExposed");
	HX_MARK_MEMBER_NAME(skew,"skew");
	 ::flixel::FlxSprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void FlxSymbol_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(coolParse,"coolParse");
	HX_VISIT_MEMBER_NAME(oldMatrix,"oldMatrix");
	HX_VISIT_MEMBER_NAME(hasFrameByPass,"hasFrameByPass");
	HX_VISIT_MEMBER_NAME(symbolAtlasShit,"symbolAtlasShit");
	HX_VISIT_MEMBER_NAME(symbolMap,"symbolMap");
	HX_VISIT_MEMBER_NAME(drawQueue,"drawQueue");
	HX_VISIT_MEMBER_NAME(daFrame,"daFrame");
	HX_VISIT_MEMBER_NAME(nestDepth,"nestDepth");
	HX_VISIT_MEMBER_NAME(transformMatrix,"transformMatrix");
	HX_VISIT_MEMBER_NAME(_skewMatrix,"_skewMatrix");
	HX_VISIT_MEMBER_NAME(matrixExposed,"matrixExposed");
	HX_VISIT_MEMBER_NAME(skew,"skew");
	 ::flixel::FlxSprite_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val FlxSymbol_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		if (HX_FIELD_EQ(inName,"skew") ) { return ::hx::Val( skew ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"daFrame") ) { return ::hx::Val( daFrame ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"setDaMap") ) { return ::hx::Val( setDaMap_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"coolParse") ) { return ::hx::Val( coolParse ); }
		if (HX_FIELD_EQ(inName,"oldMatrix") ) { return ::hx::Val( oldMatrix ); }
		if (HX_FIELD_EQ(inName,"symbolMap") ) { return ::hx::Val( symbolMap ); }
		if (HX_FIELD_EQ(inName,"drawQueue") ) { return ::hx::Val( drawQueue ); }
		if (HX_FIELD_EQ(inName,"nestDepth") ) { return ::hx::Val( nestDepth ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"renderFrame") ) { return ::hx::Val( renderFrame_dyn() ); }
		if (HX_FIELD_EQ(inName,"changeFrame") ) { return ::hx::Val( changeFrame_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawComplex") ) { return ::hx::Val( drawComplex_dyn() ); }
		if (HX_FIELD_EQ(inName,"_skewMatrix") ) { return ::hx::Val( _skewMatrix ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"matrixExposed") ) { return ::hx::Val( matrixExposed ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"hasFrameByPass") ) { return ::hx::Val( hasFrameByPass ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"symbolAtlasShit") ) { return ::hx::Val( symbolAtlasShit ); }
		if (HX_FIELD_EQ(inName,"transformMatrix") ) { return ::hx::Val( transformMatrix ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"updateSkewMatrix") ) { return ::hx::Val( updateSkewMatrix_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"parseSymbolDictionary") ) { return ::hx::Val( parseSymbolDictionary_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool FlxSymbol_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"nestedShit") ) { outValue = ( nestedShit ); return true; }
	}
	return false;
}

::hx::Val FlxSymbol_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"skew") ) { skew=inValue.Cast<  ::flixel::math::FlxPoint >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"daFrame") ) { daFrame=inValue.Cast< int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"coolParse") ) { coolParse=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"oldMatrix") ) { oldMatrix=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"symbolMap") ) { symbolMap=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		if (HX_FIELD_EQ(inName,"drawQueue") ) { drawQueue=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"nestDepth") ) { nestDepth=inValue.Cast< int >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_skewMatrix") ) { _skewMatrix=inValue.Cast<  ::openfl::geom::Matrix >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"matrixExposed") ) { matrixExposed=inValue.Cast< bool >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"hasFrameByPass") ) { hasFrameByPass=inValue.Cast< bool >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"symbolAtlasShit") ) { symbolAtlasShit=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		if (HX_FIELD_EQ(inName,"transformMatrix") ) { transformMatrix=inValue.Cast<  ::openfl::geom::Matrix >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool FlxSymbol_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"nestedShit") ) { nestedShit=ioValue.Cast<  ::haxe::ds::IntMap >(); return true; }
	}
	return false;
}

void FlxSymbol_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("coolParse",aa,8c,17,e7));
	outFields->push(HX_("oldMatrix",48,ba,b3,c6));
	outFields->push(HX_("hasFrameByPass",1b,ad,72,df));
	outFields->push(HX_("symbolAtlasShit",33,d0,21,0b));
	outFields->push(HX_("symbolMap",24,3a,ff,df));
	outFields->push(HX_("drawQueue",ed,c2,f5,25));
	outFields->push(HX_("daFrame",70,4b,b1,a0));
	outFields->push(HX_("nestDepth",4b,b9,83,ae));
	outFields->push(HX_("transformMatrix",cd,b0,1d,f7));
	outFields->push(HX_("_skewMatrix",0a,6e,a2,34));
	outFields->push(HX_("matrixExposed",5f,15,cd,ed));
	outFields->push(HX_("skew",0a,13,55,4c));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo FlxSymbol_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(FlxSymbol_obj,coolParse),HX_("coolParse",aa,8c,17,e7)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(FlxSymbol_obj,oldMatrix),HX_("oldMatrix",48,ba,b3,c6)},
	{::hx::fsBool,(int)offsetof(FlxSymbol_obj,hasFrameByPass),HX_("hasFrameByPass",1b,ad,72,df)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(int)offsetof(FlxSymbol_obj,symbolAtlasShit),HX_("symbolAtlasShit",33,d0,21,0b)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(int)offsetof(FlxSymbol_obj,symbolMap),HX_("symbolMap",24,3a,ff,df)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(FlxSymbol_obj,drawQueue),HX_("drawQueue",ed,c2,f5,25)},
	{::hx::fsInt,(int)offsetof(FlxSymbol_obj,daFrame),HX_("daFrame",70,4b,b1,a0)},
	{::hx::fsInt,(int)offsetof(FlxSymbol_obj,nestDepth),HX_("nestDepth",4b,b9,83,ae)},
	{::hx::fsObject /*  ::openfl::geom::Matrix */ ,(int)offsetof(FlxSymbol_obj,transformMatrix),HX_("transformMatrix",cd,b0,1d,f7)},
	{::hx::fsObject /*  ::openfl::geom::Matrix */ ,(int)offsetof(FlxSymbol_obj,_skewMatrix),HX_("_skewMatrix",0a,6e,a2,34)},
	{::hx::fsBool,(int)offsetof(FlxSymbol_obj,matrixExposed),HX_("matrixExposed",5f,15,cd,ed)},
	{::hx::fsObject /*  ::flixel::math::FlxPoint */ ,(int)offsetof(FlxSymbol_obj,skew),HX_("skew",0a,13,55,4c)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo FlxSymbol_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(void *) &FlxSymbol_obj::nestedShit,HX_("nestedShit",57,72,ea,8f)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String FlxSymbol_obj_sMemberFields[] = {
	HX_("coolParse",aa,8c,17,e7),
	HX_("oldMatrix",48,ba,b3,c6),
	HX_("hasFrameByPass",1b,ad,72,df),
	HX_("symbolAtlasShit",33,d0,21,0b),
	HX_("draw",04,2c,70,42),
	HX_("symbolMap",24,3a,ff,df),
	HX_("drawQueue",ed,c2,f5,25),
	HX_("daFrame",70,4b,b1,a0),
	HX_("nestDepth",4b,b9,83,ae),
	HX_("transformMatrix",cd,b0,1d,f7),
	HX_("renderFrame",f7,a4,34,d2),
	HX_("setDaMap",1d,e0,9e,e2),
	HX_("changeFrame",9d,20,49,2c),
	HX_("parseSymbolDictionary",61,27,e1,e7),
	HX_("drawComplex",8c,aa,b9,cc),
	HX_("_skewMatrix",0a,6e,a2,34),
	HX_("matrixExposed",5f,15,cd,ed),
	HX_("skew",0a,13,55,4c),
	HX_("updateSkewMatrix",54,70,04,ac),
	::String(null()) };

static void FlxSymbol_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxSymbol_obj::nestedShit,"nestedShit");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxSymbol_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxSymbol_obj::nestedShit,"nestedShit");
};

#endif

::hx::Class FlxSymbol_obj::__mClass;

static ::String FlxSymbol_obj_sStaticFields[] = {
	HX_("nestedShit",57,72,ea,8f),
	::String(null())
};

void FlxSymbol_obj::__register()
{
	FlxSymbol_obj _hx_dummy;
	FlxSymbol_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("animate.FlxSymbol",3d,01,b1,42);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxSymbol_obj::__GetStatic;
	__mClass->mSetStaticField = &FlxSymbol_obj::__SetStatic;
	__mClass->mMarkFunc = FlxSymbol_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(FlxSymbol_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FlxSymbol_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FlxSymbol_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxSymbol_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxSymbol_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxSymbol_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FlxSymbol_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_8cae46e41d5edf1a_37_boot)
HXDLIN(  37)		nestedShit =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
            	}
}

} // end namespace animate
