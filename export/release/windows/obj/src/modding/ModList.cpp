// Generated by Haxe 4.2.1+bf9ff69
#include <hxcpp.h>

#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSave
#include <flixel/util/FlxSave.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_modding_ModList
#include <modding/ModList.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_f2dd51228ddd11d8_14_setModEnabled,"modding.ModList","setModEnabled",0x394b0325,"modding.ModList.setModEnabled","modding/ModList.hx",14,0x088b2ccd)
HX_LOCAL_STACK_FRAME(_hx_pos_f2dd51228ddd11d8_21_getModEnabled,"modding.ModList","getModEnabled",0xf4452119,"modding.ModList.getModEnabled","modding/ModList.hx",21,0x088b2ccd)
HX_LOCAL_STACK_FRAME(_hx_pos_f2dd51228ddd11d8_29_getActiveMods,"modding.ModList","getActiveMods",0xec386b91,"modding.ModList.getActiveMods","modding/ModList.hx",29,0x088b2ccd)
HX_LOCAL_STACK_FRAME(_hx_pos_f2dd51228ddd11d8_43_load,"modding.ModList","load",0x602797a2,"modding.ModList.load","modding/ModList.hx",43,0x088b2ccd)
HX_LOCAL_STACK_FRAME(_hx_pos_f2dd51228ddd11d8_9_boot,"modding.ModList","boot",0x598b81ae,"modding.ModList.boot","modding/ModList.hx",9,0x088b2ccd)
HX_LOCAL_STACK_FRAME(_hx_pos_f2dd51228ddd11d8_11_boot,"modding.ModList","boot",0x598b81ae,"modding.ModList.boot","modding/ModList.hx",11,0x088b2ccd)
namespace modding{

void ModList_obj::__construct() { }

Dynamic ModList_obj::__CreateEmpty() { return new ModList_obj; }

void *ModList_obj::_hx_vtable = 0;

Dynamic ModList_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ModList_obj > _hx_result = new ModList_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ModList_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7f6685b8;
}

 ::haxe::ds::StringMap ModList_obj::modList;

 ::haxe::ds::StringMap ModList_obj::modMetadatas;

void ModList_obj::setModEnabled(::String mod,bool enabled){
            	HX_STACKFRAME(&_hx_pos_f2dd51228ddd11d8_14_setModEnabled)
HXLINE(  15)		::modding::ModList_obj::modList->set(mod,enabled);
HXLINE(  16)		::flixel::FlxG_obj::save->data->__SetField(HX_("modList",40,e8,de,dc),::modding::ModList_obj::modList,::hx::paccDynamic);
HXLINE(  17)		::flixel::FlxG_obj::save->flush(null(),null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(ModList_obj,setModEnabled,(void))

bool ModList_obj::getModEnabled(::String mod){
            	HX_STACKFRAME(&_hx_pos_f2dd51228ddd11d8_21_getModEnabled)
HXLINE(  22)		if (!(::modding::ModList_obj::modList->exists(mod))) {
HXLINE(  23)			::modding::ModList_obj::setModEnabled(mod,false);
            		}
HXLINE(  25)		return ::modding::ModList_obj::modList->get_bool(mod);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ModList_obj,getModEnabled,return )

::Array< ::String > ModList_obj::getActiveMods(::Array< ::String > modsToCheck){
            	HX_STACKFRAME(&_hx_pos_f2dd51228ddd11d8_29_getActiveMods)
HXLINE(  30)		::Array< ::String > activeMods = ::Array_obj< ::String >::__new(0);
HXLINE(  32)		{
HXLINE(  32)			int _g = 0;
HXDLIN(  32)			while((_g < modsToCheck->length)){
HXLINE(  32)				::String modName = modsToCheck->__get(_g);
HXDLIN(  32)				_g = (_g + 1);
HXLINE(  34)				if (::modding::ModList_obj::getModEnabled(modName)) {
HXLINE(  35)					activeMods->push(modName);
            				}
            			}
            		}
HXLINE(  38)		return activeMods;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ModList_obj,getActiveMods,return )

void ModList_obj::load(){
            	HX_STACKFRAME(&_hx_pos_f2dd51228ddd11d8_43_load)
HXDLIN(  43)		if (::hx::IsNotNull( ::flixel::FlxG_obj::save->data->__Field(HX_("modList",40,e8,de,dc),::hx::paccDynamic) )) {
HXLINE(  44)			::modding::ModList_obj::modList = ( ( ::haxe::ds::StringMap)(::flixel::FlxG_obj::save->data->__Field(HX_("modList",40,e8,de,dc),::hx::paccDynamic)) );
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(ModList_obj,load,(void))


ModList_obj::ModList_obj()
{
}

bool ModList_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"load") ) { outValue = load_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"modList") ) { outValue = ( modList ); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"modMetadatas") ) { outValue = ( modMetadatas ); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"setModEnabled") ) { outValue = setModEnabled_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getModEnabled") ) { outValue = getModEnabled_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getActiveMods") ) { outValue = getActiveMods_dyn(); return true; }
	}
	return false;
}

bool ModList_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"modList") ) { modList=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"modMetadatas") ) { modMetadatas=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *ModList_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo ModList_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &ModList_obj::modList,HX_("modList",40,e8,de,dc)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &ModList_obj::modMetadatas,HX_("modMetadatas",02,7b,6c,74)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void ModList_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ModList_obj::modList,"modList");
	HX_MARK_MEMBER_NAME(ModList_obj::modMetadatas,"modMetadatas");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ModList_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ModList_obj::modList,"modList");
	HX_VISIT_MEMBER_NAME(ModList_obj::modMetadatas,"modMetadatas");
};

#endif

::hx::Class ModList_obj::__mClass;

static ::String ModList_obj_sStaticFields[] = {
	HX_("modList",40,e8,de,dc),
	HX_("modMetadatas",02,7b,6c,74),
	HX_("setModEnabled",21,90,10,9b),
	HX_("getModEnabled",15,ae,0a,56),
	HX_("getActiveMods",8d,f8,fd,4d),
	HX_("load",26,9a,b7,47),
	::String(null())
};

void ModList_obj::__register()
{
	ModList_obj _hx_dummy;
	ModList_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("modding.ModList",72,54,dd,11);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ModList_obj::__GetStatic;
	__mClass->mSetStaticField = &ModList_obj::__SetStatic;
	__mClass->mMarkFunc = ModList_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(ModList_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< ModList_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ModList_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ModList_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ModList_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void ModList_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_f2dd51228ddd11d8_9_boot)
HXDLIN(   9)		modList =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_f2dd51228ddd11d8_11_boot)
HXDLIN(  11)		modMetadatas =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            	}
}

} // end namespace modding
