// Generated by Haxe 4.3.1
#include <hxcpp.h>

#ifndef INCLUDED_Alphabet
#include <Alphabet.h>
#endif
#ifndef INCLUDED_Controls
#include <Controls.h>
#endif
#ifndef INCLUDED_MainMenuState
#include <MainMenuState.h>
#endif
#ifndef INCLUDED_MusicBeatState
#include <MusicBeatState.h>
#endif
#ifndef INCLUDED_Paths
#include <Paths.h>
#endif
#ifndef INCLUDED_PlayerSettings
#include <PlayerSettings.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxGame
#include <flixel/FlxGame.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_FlxTransitionableState
#include <flixel/addons/transition/FlxTransitionableState.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_TransitionData
#include <flixel/addons/transition/TransitionData.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_FlxUIState
#include <flixel/addons/ui/FlxUIState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IEventGetter
#include <flixel/addons/ui/interfaces/IEventGetter.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IFlxUIState
#include <flixel/addons/ui/interfaces/IFlxUIState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_actions_FlxAction
#include <flixel/input/actions/FlxAction.h>
#endif
#ifndef INCLUDED_flixel_input_actions_FlxActionDigital
#include <flixel/input/actions/FlxActionDigital.h>
#endif
#ifndef INCLUDED_flixel_input_actions_FlxActionSet
#include <flixel/input/actions/FlxActionSet.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_system_FlxSound
#include <flixel/system/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_system_FlxSoundGroup
#include <flixel/system/FlxSoundGroup.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SoundFrontEnd
#include <flixel/system/frontEnds/SoundFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_ui_FlxButton
#include <flixel/ui/FlxButton.h>
#endif
#ifndef INCLUDED_flixel_ui_FlxTypedButton_flixel_text_FlxText
#include <flixel/ui/FlxTypedButton_flixel_text_FlxText.h>
#endif
#ifndef INCLUDED_flixel_util_FlxAxes
#include <flixel/util/FlxAxes.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSave
#include <flixel/util/FlxSave.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_modding_ModList
#include <modding/ModList.h>
#endif
#ifndef INCLUDED_modding_ModsMenuState
#include <modding/ModsMenuState.h>
#endif
#ifndef INCLUDED_modding_ModsMenuStateOption
#include <modding/ModsMenuStateOption.h>
#endif
#ifndef INCLUDED_modding_PolymodHandler
#include <modding/PolymodHandler.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_polymod_ModMetadata
#include <polymod/ModMetadata.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_33b15cae6874b8dc_36_new,"modding.ModsMenuState","new",0x4a6b2a65,"modding.ModsMenuState.new","modding/ModsMenuState.hx",36,0x60d8baac)
HX_LOCAL_STACK_FRAME(_hx_pos_33b15cae6874b8dc_55_create,"modding.ModsMenuState","create",0xdada5e17,"modding.ModsMenuState.create","modding/ModsMenuState.hx",55,0x60d8baac)
HX_LOCAL_STACK_FRAME(_hx_pos_33b15cae6874b8dc_100_loadMods,"modding.ModsMenuState","loadMods",0x99cbd892,"modding.ModsMenuState.loadMods","modding/ModsMenuState.hx",100,0x60d8baac)
HX_LOCAL_STACK_FRAME(_hx_pos_33b15cae6874b8dc_98_loadMods,"modding.ModsMenuState","loadMods",0x99cbd892,"modding.ModsMenuState.loadMods","modding/ModsMenuState.hx",98,0x60d8baac)
HX_LOCAL_STACK_FRAME(_hx_pos_33b15cae6874b8dc_127_buildUI,"modding.ModsMenuState","buildUI",0x02880d87,"modding.ModsMenuState.buildUI","modding/ModsMenuState.hx",127,0x60d8baac)
HX_LOCAL_STACK_FRAME(_hx_pos_33b15cae6874b8dc_137_buildUI,"modding.ModsMenuState","buildUI",0x02880d87,"modding.ModsMenuState.buildUI","modding/ModsMenuState.hx",137,0x60d8baac)
HX_LOCAL_STACK_FRAME(_hx_pos_33b15cae6874b8dc_125_buildUI,"modding.ModsMenuState","buildUI",0x02880d87,"modding.ModsMenuState.buildUI","modding/ModsMenuState.hx",125,0x60d8baac)
HX_LOCAL_STACK_FRAME(_hx_pos_33b15cae6874b8dc_166_update,"modding.ModsMenuState","update",0xe5d07d24,"modding.ModsMenuState.update","modding/ModsMenuState.hx",166,0x60d8baac)
HX_LOCAL_STACK_FRAME(_hx_pos_33b15cae6874b8dc_220_setLabelOffset,"modding.ModsMenuState","setLabelOffset",0xb78e4e40,"modding.ModsMenuState.setLabelOffset","modding/ModsMenuState.hx",220,0x60d8baac)
HX_LOCAL_STACK_FRAME(_hx_pos_33b15cae6874b8dc_45_boot,"modding.ModsMenuState","boot",0xcb72ee8d,"modding.ModsMenuState.boot","modding/ModsMenuState.hx",45,0x60d8baac)
namespace modding{

void ModsMenuState_obj::__construct( ::flixel::addons::transition::TransitionData TransIn, ::flixel::addons::transition::TransitionData TransOut){
            	HX_GC_STACKFRAME(&_hx_pos_33b15cae6874b8dc_36_new)
HXLINE(  41)		this->page =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  39)		this->curSelected = 0;
HXLINE(  36)		super::__construct(TransIn,TransOut);
            	}

Dynamic ModsMenuState_obj::__CreateEmpty() { return new ModsMenuState_obj; }

void *ModsMenuState_obj::_hx_vtable = 0;

Dynamic ModsMenuState_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ModsMenuState_obj > _hx_result = new ModsMenuState_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool ModsMenuState_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x62817b24) {
		if (inClassId<=(int)0x2f064378) {
			if (inClassId<=(int)0x23a57bae) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x23a57bae;
			} else {
				return inClassId==(int)0x2f064378;
			}
		} else {
			return inClassId==(int)0x3f706236 || inClassId==(int)0x62817b24;
		}
	} else {
		if (inClassId<=(int)0x7c795c9f) {
			return inClassId==(int)0x6ebb3361 || inClassId==(int)0x7c795c9f;
		} else {
			return inClassId==(int)0x7ccf8994;
		}
	}
}

void ModsMenuState_obj::create(){
            	HX_GC_STACKFRAME(&_hx_pos_33b15cae6874b8dc_55_create)
HXLINE(  58)		if (( (bool)(::flixel::FlxG_obj::save->data->__Field(HX_("mousescroll",f2,97,58,08),::hx::paccDynamic)) )) {
HXLINE(  60)			::flixel::FlxG_obj::mouse->set_visible(true);
            		}
HXLINE(  63)		 ::flixel::FlxSprite menuBG =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null());
HXDLIN(  63)		::String library = null();
HXLINE(  56)		 ::flixel::FlxSprite menuBG1 = menuBG->loadGraphic(::Paths_obj::getPath(((HX_("images/",77,50,74,c1) + HX_("menuDesat",26,91,04,72)) + HX_(".png",3b,2d,bd,1e)),HX_("IMAGE",3b,57,57,3b),library),null(),null(),null(),null(),null());
HXLINE(  65)		menuBG1->set_color(-8355712);
HXLINE(  66)		menuBG1->setGraphicSize(::Std_obj::_hx_int((menuBG1->get_width() * ((Float)1.1))),null());
HXLINE(  67)		menuBG1->updateHitbox();
HXLINE(  68)		{
HXLINE(  68)			 ::flixel::util::FlxAxes axes = ::flixel::util::FlxAxes_obj::XY_dyn();
HXDLIN(  68)			bool _hx_tmp;
HXDLIN(  68)			switch((int)(axes->_hx_getIndex())){
            				case (int)0: case (int)2: {
HXLINE(  68)					_hx_tmp = true;
            				}
            				break;
            				default:{
HXLINE(  68)					_hx_tmp = false;
            				}
            			}
HXDLIN(  68)			if (_hx_tmp) {
HXLINE(  68)				int _hx_tmp1 = ::flixel::FlxG_obj::width;
HXDLIN(  68)				menuBG1->set_x(((( (Float)(_hx_tmp1) ) - menuBG1->get_width()) / ( (Float)(2) )));
            			}
HXDLIN(  68)			bool _hx_tmp2;
HXDLIN(  68)			switch((int)(axes->_hx_getIndex())){
            				case (int)1: case (int)2: {
HXLINE(  68)					_hx_tmp2 = true;
            				}
            				break;
            				default:{
HXLINE(  68)					_hx_tmp2 = false;
            				}
            			}
HXDLIN(  68)			if (_hx_tmp2) {
HXLINE(  68)				int _hx_tmp3 = ::flixel::FlxG_obj::height;
HXDLIN(  68)				menuBG1->set_y(((( (Float)(_hx_tmp3) ) - menuBG1->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE(  69)		menuBG1->set_antialiasing(true);
HXLINE(  70)		this->add(menuBG1);
HXLINE(  72)		this->infoText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,0,0,0,HX_("NO MODS INSTALLED!",37,47,28,fe),12,null());
HXLINE(  73)		this->infoText->scrollFactor->set(null(),null());
HXLINE(  74)		this->infoText->setFormat(HX_("VCR OSD Mono",be,44,e4,b8),35,-1,HX_("center",d5,25,db,05),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE(  75)		this->infoText->set_borderSize(( (Float)(2) ));
HXLINE(  76)		{
HXLINE(  76)			 ::flixel::text::FlxText _this = this->infoText;
HXDLIN(  76)			 ::flixel::util::FlxAxes axes1 = ::flixel::util::FlxAxes_obj::XY_dyn();
HXDLIN(  76)			bool _hx_tmp4;
HXDLIN(  76)			switch((int)(axes1->_hx_getIndex())){
            				case (int)0: case (int)2: {
HXLINE(  76)					_hx_tmp4 = true;
            				}
            				break;
            				default:{
HXLINE(  76)					_hx_tmp4 = false;
            				}
            			}
HXDLIN(  76)			if (_hx_tmp4) {
HXLINE(  76)				int _hx_tmp5 = ::flixel::FlxG_obj::width;
HXDLIN(  76)				_this->set_x(((( (Float)(_hx_tmp5) ) - _this->get_width()) / ( (Float)(2) )));
            			}
HXDLIN(  76)			bool _hx_tmp6;
HXDLIN(  76)			switch((int)(axes1->_hx_getIndex())){
            				case (int)1: case (int)2: {
HXLINE(  76)					_hx_tmp6 = true;
            				}
            				break;
            				default:{
HXLINE(  76)					_hx_tmp6 = false;
            				}
            			}
HXDLIN(  76)			if (_hx_tmp6) {
HXLINE(  76)				int _hx_tmp7 = ::flixel::FlxG_obj::height;
HXDLIN(  76)				_this->set_y(((( (Float)(_hx_tmp7) ) - _this->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE(  77)		this->infoText->set_visible(false);
HXLINE(  78)		this->infoText->set_antialiasing(true);
HXLINE(  79)		this->add(this->infoText);
HXLINE(  81)		this->infoTextcool =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,340,340,::Std_obj::_hx_int((( (Float)(::flixel::FlxG_obj::width) ) * ((Float)0.9))),HX_("",00,00,00,00),12,null());
HXLINE(  82)		this->infoTextcool->scrollFactor->set(null(),null());
HXLINE(  83)		this->infoTextcool->setFormat((HX_("assets/fonts/",37,ff,a5,9c) + HX_("FridayNightFunkin-Regular.ttf",11,db,3e,23)),40,-1,HX_("center",d5,25,db,05),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE(  84)		this->infoTextcool->set_borderSize(( (Float)(2) ));
HXLINE(  85)		{
HXLINE(  85)			 ::flixel::text::FlxText _this1 = this->infoTextcool;
HXDLIN(  85)			 ::flixel::util::FlxAxes axes2 = ::flixel::util::FlxAxes_obj::Y_dyn();
HXDLIN(  85)			if (::hx::IsNull( axes2 )) {
HXLINE(  85)				axes2 = ::flixel::util::FlxAxes_obj::XY_dyn();
            			}
HXDLIN(  85)			bool _hx_tmp8;
HXDLIN(  85)			switch((int)(axes2->_hx_getIndex())){
            				case (int)0: case (int)2: {
HXLINE(  85)					_hx_tmp8 = true;
            				}
            				break;
            				default:{
HXLINE(  85)					_hx_tmp8 = false;
            				}
            			}
HXDLIN(  85)			if (_hx_tmp8) {
HXLINE(  85)				int _hx_tmp9 = ::flixel::FlxG_obj::width;
HXDLIN(  85)				_this1->set_x(((( (Float)(_hx_tmp9) ) - _this1->get_width()) / ( (Float)(2) )));
            			}
HXDLIN(  85)			bool _hx_tmp10;
HXDLIN(  85)			switch((int)(axes2->_hx_getIndex())){
            				case (int)1: case (int)2: {
HXLINE(  85)					_hx_tmp10 = true;
            				}
            				break;
            				default:{
HXLINE(  85)					_hx_tmp10 = false;
            				}
            			}
HXDLIN(  85)			if (_hx_tmp10) {
HXLINE(  85)				int _hx_tmp11 = ::flixel::FlxG_obj::height;
HXDLIN(  85)				_this1->set_y(((( (Float)(_hx_tmp11) ) - _this1->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE(  87)		this->super::create();
HXLINE(  89)		::modding::PolymodHandler_obj::loadModMetadata();
HXLINE(  91)		this->add(this->page);
HXLINE(  93)		this->loadMods();
HXLINE(  94)		::flixel::FlxG_obj::mouse->set_visible(true);
            	}


void ModsMenuState_obj::loadMods(){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::modding::ModsMenuState,_gthis) HXARGC(1)
            		void _hx_run( ::modding::ModsMenuStateOption option){
            			HX_STACKFRAME(&_hx_pos_33b15cae6874b8dc_100_loadMods)
HXLINE( 101)			_gthis->page->remove(option,null()).StaticCast<  ::modding::ModsMenuStateOption >();
HXLINE( 102)			option->kill();
HXLINE( 103)			option->destroy();
            		}
            		HX_END_LOCAL_FUNC1((void))

            	HX_GC_STACKFRAME(&_hx_pos_33b15cae6874b8dc_98_loadMods)
HXDLIN(  98)		 ::modding::ModsMenuState _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE(  99)		this->page->forEachExists( ::Dynamic(new _hx_Closure_0(_gthis)),null());
HXLINE( 106)		int optionLoopNum = 0;
HXLINE( 108)		{
HXLINE( 108)			int _g = 0;
HXDLIN( 108)			::Array< ::String > _g1 = ::modding::PolymodHandler_obj::metadataArrays;
HXDLIN( 108)			while((_g < _g1->length)){
HXLINE( 108)				::String modId = _g1->__get(_g);
HXDLIN( 108)				_g = (_g + 1);
HXLINE( 110)				 ::modding::ModsMenuStateOption modOption =  ::modding::ModsMenuStateOption_obj::__alloc( HX_CTX ,( ( ::polymod::ModMetadata)(::modding::ModList_obj::modMetadatas->get(modId)) )->title,modId,optionLoopNum);
HXLINE( 111)				this->page->add(modOption).StaticCast<  ::modding::ModsMenuStateOption >();
HXLINE( 112)				optionLoopNum = (optionLoopNum + 1);
HXLINE( 113)				::modding::ModsMenuState_obj::coolId = modId;
            			}
            		}
HXLINE( 116)		if ((optionLoopNum > 0)) {
HXLINE( 118)			this->buildUI();
            		}
HXLINE( 121)		this->infoText->set_visible((this->page->length == 0));
            	}


HX_DEFINE_DYNAMIC_FUNC0(ModsMenuState_obj,loadMods,(void))

void ModsMenuState_obj::buildUI(){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::modding::ModsMenuState,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_STACKFRAME(&_hx_pos_33b15cae6874b8dc_127_buildUI)
HXLINE( 128)			Dynamic( _gthis->page->members->__get(_gthis->curSelected)).StaticCast<  ::modding::ModsMenuStateOption >()->Mod_Enabled = true;
HXLINE( 129)			if (!(::modding::ModsMenuState_obj::enabledMods->contains(Dynamic( _gthis->page->members->__get(_gthis->curSelected)).StaticCast<  ::modding::ModsMenuStateOption >()->Option_Value))) {
HXLINE( 131)				::modding::ModsMenuState_obj::enabledMods->push(Dynamic( _gthis->page->members->__get(_gthis->curSelected)).StaticCast<  ::modding::ModsMenuStateOption >()->Option_Value);
            			}
HXLINE( 133)			::modding::ModList_obj::setModEnabled(Dynamic( _gthis->page->members->__get(_gthis->curSelected)).StaticCast<  ::modding::ModsMenuStateOption >()->Option_Value,Dynamic( _gthis->page->members->__get(_gthis->curSelected)).StaticCast<  ::modding::ModsMenuStateOption >()->Mod_Enabled);
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_1, ::modding::ModsMenuState,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_33b15cae6874b8dc_137_buildUI)
HXLINE( 138)			Dynamic( _gthis->page->members->__get(_gthis->curSelected)).StaticCast<  ::modding::ModsMenuStateOption >()->Mod_Enabled = false;
HXLINE( 139)			if (::modding::ModsMenuState_obj::enabledMods->contains(Dynamic( _gthis->page->members->__get(_gthis->curSelected)).StaticCast<  ::modding::ModsMenuStateOption >()->Option_Value)) {
HXLINE( 141)				::modding::ModsMenuState_obj::enabledMods->remove(Dynamic( _gthis->page->members->__get(_gthis->curSelected)).StaticCast<  ::modding::ModsMenuStateOption >()->Option_Value);
            			}
HXLINE( 143)			::modding::ModList_obj::setModEnabled(Dynamic( _gthis->page->members->__get(_gthis->curSelected)).StaticCast<  ::modding::ModsMenuStateOption >()->Option_Value,Dynamic( _gthis->page->members->__get(_gthis->curSelected)).StaticCast<  ::modding::ModsMenuStateOption >()->Mod_Enabled);
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_GC_STACKFRAME(&_hx_pos_33b15cae6874b8dc_125_buildUI)
HXDLIN( 125)		 ::modding::ModsMenuState _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 126)		::modding::ModsMenuState_obj::enableButton =  ::flixel::ui::FlxButton_obj::__alloc( HX_CTX ,1120,309,HX_("Enable Mod",a5,52,87,7a), ::Dynamic(new _hx_Closure_0(_gthis)));
HXLINE( 136)		::modding::ModsMenuState_obj::disableButton =  ::flixel::ui::FlxButton_obj::__alloc( HX_CTX ,1120,380,HX_("Disable Mod",4a,b8,cb,de), ::Dynamic(new _hx_Closure_1(_gthis)));
HXLINE( 146)		::modding::ModsMenuState_obj::enableButton->setGraphicSize(150,70);
HXLINE( 147)		::modding::ModsMenuState_obj::enableButton->updateHitbox();
HXLINE( 148)		::modding::ModsMenuState_obj::enableButton->set_color(-16744448);
HXLINE( 149)		::modding::ModsMenuState_obj::enableButton->label->setFormat((HX_("assets/fonts/",37,ff,a5,9c) + HX_("pixel.otf",b9,f1,6c,ed)),12,-1,null(),null(),null(),null());
HXLINE( 150)		::modding::ModsMenuState_obj::enableButton->label->set_fieldWidth(( (Float)(135) ));
HXLINE( 151)		this->setLabelOffset(::modding::ModsMenuState_obj::enableButton,( (Float)(5) ),( (Float)(22) ));
HXLINE( 153)		::modding::ModsMenuState_obj::disableButton->setGraphicSize(150,70);
HXLINE( 154)		::modding::ModsMenuState_obj::disableButton->updateHitbox();
HXLINE( 155)		::modding::ModsMenuState_obj::disableButton->set_color(-65536);
HXLINE( 156)		::modding::ModsMenuState_obj::disableButton->label->setFormat((HX_("assets/fonts/",37,ff,a5,9c) + HX_("pixel.otf",b9,f1,6c,ed)),12,-1,null(),null(),null(),null());
HXLINE( 157)		::modding::ModsMenuState_obj::disableButton->label->set_fieldWidth(( (Float)(135) ));
HXLINE( 158)		this->setLabelOffset(::modding::ModsMenuState_obj::disableButton,( (Float)(5) ),( (Float)(22) ));
HXLINE( 160)		this->add(this->infoTextcool);
HXLINE( 161)		this->add(::modding::ModsMenuState_obj::disableButton);
HXLINE( 162)		this->add(::modding::ModsMenuState_obj::enableButton);
            	}


HX_DEFINE_DYNAMIC_FUNC0(ModsMenuState_obj,buildUI,(void))

void ModsMenuState_obj::update(Float elapsed){
            	HX_GC_STACKFRAME(&_hx_pos_33b15cae6874b8dc_166_update)
HXLINE( 167)		this->super::update(elapsed);
HXLINE( 170)		if ((this->page->length > 0)) {
HXLINE( 172)			 ::flixel::text::FlxText _hx_tmp = this->infoTextcool;
HXDLIN( 172)			_hx_tmp->set_text(( ( ::polymod::ModMetadata)(::modding::ModList_obj::modMetadatas->get(::modding::PolymodHandler_obj::metadataArrays->__get(this->curSelected))) )->description);
HXLINE( 173)			this->infoTextcool->set_visible(true);
HXLINE( 174)			this->infoTextcool->set_antialiasing(true);
            		}
HXLINE( 177)		if ((this->page->length > 0)) {
HXLINE( 179)			if (::PlayerSettings_obj::player1->controls->_upP->check()) {
HXLINE( 181)				this->curSelected--;
HXLINE( 182)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp1 = ::flixel::FlxG_obj::sound;
HXDLIN( 182)				_hx_tmp1->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.4),null(),null(),null(),null());
            			}
HXLINE( 185)			if (::PlayerSettings_obj::player1->controls->_downP->check()) {
HXLINE( 187)				this->curSelected++;
HXLINE( 188)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp2 = ::flixel::FlxG_obj::sound;
HXDLIN( 188)				_hx_tmp2->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.4),null(),null(),null(),null());
            			}
            		}
HXLINE( 192)		if (::PlayerSettings_obj::player1->controls->_back->check()) {
HXLINE( 194)			 ::flixel::FlxState nextState =  ::MainMenuState_obj::__alloc( HX_CTX ,null(),null());
HXDLIN( 194)			if (::flixel::FlxG_obj::game->_state->switchTo(nextState)) {
HXLINE( 194)				::flixel::FlxG_obj::game->_requestedState = nextState;
            			}
            		}
HXLINE( 197)		if (::PlayerSettings_obj::player1->controls->_accept->check()) {
HXLINE( 199)			 ::flixel::FlxState nextState1 =  ::MainMenuState_obj::__alloc( HX_CTX ,null(),null());
HXDLIN( 199)			if (::flixel::FlxG_obj::game->_state->switchTo(nextState1)) {
HXLINE( 199)				::flixel::FlxG_obj::game->_requestedState = nextState1;
            			}
            		}
HXLINE( 202)		if ((this->curSelected < 0)) {
HXLINE( 203)			this->curSelected = (this->page->length - 1);
            		}
HXLINE( 205)		if ((this->curSelected >= this->page->length)) {
HXLINE( 206)			this->curSelected = 0;
            		}
HXLINE( 208)		int bruh = 0;
HXLINE( 210)		{
HXLINE( 210)			int _g = 0;
HXDLIN( 210)			::Array< ::Dynamic> _g1 = this->page->members;
HXDLIN( 210)			while((_g < _g1->length)){
HXLINE( 210)				 ::modding::ModsMenuStateOption x = _g1->__get(_g).StaticCast<  ::modding::ModsMenuStateOption >();
HXDLIN( 210)				_g = (_g + 1);
HXLINE( 212)				x->Alphabet_Text->targetY = ( (Float)((bruh - this->curSelected)) );
HXLINE( 213)				bruh = (bruh + 1);
            			}
            		}
            	}


void ModsMenuState_obj::setLabelOffset( ::flixel::ui::FlxButton button,Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_33b15cae6874b8dc_220_setLabelOffset)
HXDLIN( 220)		int _g = 0;
HXDLIN( 220)		::Array< ::Dynamic> _g1 = button->labelOffsets;
HXDLIN( 220)		while((_g < _g1->length)){
HXDLIN( 220)			 ::flixel::math::FlxPoint point = _g1->__get(_g).StaticCast<  ::flixel::math::FlxPoint >();
HXDLIN( 220)			_g = (_g + 1);
HXLINE( 222)			point->set(x,y);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(ModsMenuState_obj,setLabelOffset,(void))

 ::modding::ModsMenuState ModsMenuState_obj::instance;

::Array< ::String > ModsMenuState_obj::enabledMods;

::String ModsMenuState_obj::coolId;

 ::flixel::ui::FlxButton ModsMenuState_obj::disableButton;

 ::flixel::ui::FlxButton ModsMenuState_obj::enableButton;


::hx::ObjectPtr< ModsMenuState_obj > ModsMenuState_obj::__new( ::flixel::addons::transition::TransitionData TransIn, ::flixel::addons::transition::TransitionData TransOut) {
	::hx::ObjectPtr< ModsMenuState_obj > __this = new ModsMenuState_obj();
	__this->__construct(TransIn,TransOut);
	return __this;
}

::hx::ObjectPtr< ModsMenuState_obj > ModsMenuState_obj::__alloc(::hx::Ctx *_hx_ctx, ::flixel::addons::transition::TransitionData TransIn, ::flixel::addons::transition::TransitionData TransOut) {
	ModsMenuState_obj *__this = (ModsMenuState_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ModsMenuState_obj), true, "modding.ModsMenuState"));
	*(void **)__this = ModsMenuState_obj::_hx_vtable;
	__this->__construct(TransIn,TransOut);
	return __this;
}

ModsMenuState_obj::ModsMenuState_obj()
{
}

void ModsMenuState_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ModsMenuState);
	HX_MARK_MEMBER_NAME(curSelected,"curSelected");
	HX_MARK_MEMBER_NAME(page,"page");
	HX_MARK_MEMBER_NAME(infoText,"infoText");
	HX_MARK_MEMBER_NAME(infoTextcool,"infoTextcool");
	 ::flixel::addons::ui::FlxUIState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void ModsMenuState_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(curSelected,"curSelected");
	HX_VISIT_MEMBER_NAME(page,"page");
	HX_VISIT_MEMBER_NAME(infoText,"infoText");
	HX_VISIT_MEMBER_NAME(infoTextcool,"infoTextcool");
	 ::flixel::addons::ui::FlxUIState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val ModsMenuState_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"page") ) { return ::hx::Val( page ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"create") ) { return ::hx::Val( create_dyn() ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"buildUI") ) { return ::hx::Val( buildUI_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"infoText") ) { return ::hx::Val( infoText ); }
		if (HX_FIELD_EQ(inName,"loadMods") ) { return ::hx::Val( loadMods_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"curSelected") ) { return ::hx::Val( curSelected ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"infoTextcool") ) { return ::hx::Val( infoTextcool ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"setLabelOffset") ) { return ::hx::Val( setLabelOffset_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool ModsMenuState_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"coolId") ) { outValue = ( coolId ); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"instance") ) { outValue = ( instance ); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"enabledMods") ) { outValue = ( enabledMods ); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"enableButton") ) { outValue = ( enableButton ); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"disableButton") ) { outValue = ( disableButton ); return true; }
	}
	return false;
}

::hx::Val ModsMenuState_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"page") ) { page=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"infoText") ) { infoText=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"curSelected") ) { curSelected=inValue.Cast< int >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"infoTextcool") ) { infoTextcool=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool ModsMenuState_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"coolId") ) { coolId=ioValue.Cast< ::String >(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"instance") ) { instance=ioValue.Cast<  ::modding::ModsMenuState >(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"enabledMods") ) { enabledMods=ioValue.Cast< ::Array< ::String > >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"enableButton") ) { enableButton=ioValue.Cast<  ::flixel::ui::FlxButton >(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"disableButton") ) { disableButton=ioValue.Cast<  ::flixel::ui::FlxButton >(); return true; }
	}
	return false;
}

void ModsMenuState_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("curSelected",fb,eb,ab,32));
	outFields->push(HX_("page",4f,da,51,4a));
	outFields->push(HX_("infoText",3b,00,9e,3d));
	outFields->push(HX_("infoTextcool",84,f4,06,9f));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo ModsMenuState_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(ModsMenuState_obj,curSelected),HX_("curSelected",fb,eb,ab,32)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(ModsMenuState_obj,page),HX_("page",4f,da,51,4a)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(ModsMenuState_obj,infoText),HX_("infoText",3b,00,9e,3d)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(ModsMenuState_obj,infoTextcool),HX_("infoTextcool",84,f4,06,9f)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo ModsMenuState_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::modding::ModsMenuState */ ,(void *) &ModsMenuState_obj::instance,HX_("instance",95,1f,e1,59)},
	{::hx::fsObject /* ::Array< ::String > */ ,(void *) &ModsMenuState_obj::enabledMods,HX_("enabledMods",92,d8,ed,fe)},
	{::hx::fsString,(void *) &ModsMenuState_obj::coolId,HX_("coolId",04,ff,7f,c8)},
	{::hx::fsObject /*  ::flixel::ui::FlxButton */ ,(void *) &ModsMenuState_obj::disableButton,HX_("disableButton",fa,9d,f5,4e)},
	{::hx::fsObject /*  ::flixel::ui::FlxButton */ ,(void *) &ModsMenuState_obj::enableButton,HX_("enableButton",d5,c8,6e,84)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String ModsMenuState_obj_sMemberFields[] = {
	HX_("curSelected",fb,eb,ab,32),
	HX_("page",4f,da,51,4a),
	HX_("infoText",3b,00,9e,3d),
	HX_("infoTextcool",84,f4,06,9f),
	HX_("create",fc,66,0f,7c),
	HX_("loadMods",b7,a4,00,b9),
	HX_("buildUI",02,cd,ba,6f),
	HX_("update",09,86,05,87),
	HX_("setLabelOffset",25,44,fe,52),
	::String(null()) };

static void ModsMenuState_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ModsMenuState_obj::instance,"instance");
	HX_MARK_MEMBER_NAME(ModsMenuState_obj::enabledMods,"enabledMods");
	HX_MARK_MEMBER_NAME(ModsMenuState_obj::coolId,"coolId");
	HX_MARK_MEMBER_NAME(ModsMenuState_obj::disableButton,"disableButton");
	HX_MARK_MEMBER_NAME(ModsMenuState_obj::enableButton,"enableButton");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ModsMenuState_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ModsMenuState_obj::instance,"instance");
	HX_VISIT_MEMBER_NAME(ModsMenuState_obj::enabledMods,"enabledMods");
	HX_VISIT_MEMBER_NAME(ModsMenuState_obj::coolId,"coolId");
	HX_VISIT_MEMBER_NAME(ModsMenuState_obj::disableButton,"disableButton");
	HX_VISIT_MEMBER_NAME(ModsMenuState_obj::enableButton,"enableButton");
};

#endif

::hx::Class ModsMenuState_obj::__mClass;

static ::String ModsMenuState_obj_sStaticFields[] = {
	HX_("instance",95,1f,e1,59),
	HX_("enabledMods",92,d8,ed,fe),
	HX_("coolId",04,ff,7f,c8),
	HX_("disableButton",fa,9d,f5,4e),
	HX_("enableButton",d5,c8,6e,84),
	::String(null())
};

void ModsMenuState_obj::__register()
{
	ModsMenuState_obj _hx_dummy;
	ModsMenuState_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("modding.ModsMenuState",f3,13,cb,e2);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ModsMenuState_obj::__GetStatic;
	__mClass->mSetStaticField = &ModsMenuState_obj::__SetStatic;
	__mClass->mMarkFunc = ModsMenuState_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(ModsMenuState_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ModsMenuState_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ModsMenuState_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ModsMenuState_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ModsMenuState_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ModsMenuState_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void ModsMenuState_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_33b15cae6874b8dc_45_boot)
HXDLIN(  45)		enabledMods = ::Array_obj< ::String >::__new(0);
            	}
}

} // end namespace modding
